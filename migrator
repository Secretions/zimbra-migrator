#!/usr/bin/python

# to set ssl level
import ssl

import re
import ast
import argparse
try:
    import configparser
except:
    import ConfigParser as configparser
from subprocess import call

import pysimplesoap
import zimbrasoap

config = configparser.RawConfigParser()
args = ''

##### Account Attribute notes

### Seem to be unused for technical reasons
### (if this list is ever used to migrate from non-zimbra directories, these
###  may be come relevant)
#
# c - unused (co is used)
# gn - alias of givenName, never shows up on its own
# o - never see this on an account in zimbra (used on domains, but automatic)
# streetAddress - alias of street

### Just never used
# destinationIndicator
# internationalISDNNumber - if you have one one of these, I'll take you to dinner
# postOfficeBox 
# postalAddress
# preferredDeliveryMethod
# registeredAddress
# teletexTerminalIdentifier - rfc4519's description of this even says it's bunk
# telexNumber - I preferred terminate over telix and telemate
# userCertificate - I don't believe this is used
# userPassword - Not available via SOAP
# userSMIMECertificate - Ditto to userCertificate (S/MIME zimlet does something else)
# x121Address

### Admin stuff
# zimbraACE - Zimbra ACLs, not settings
# zimbraAdminAuthTokenLifetime - More a system-level decision
# zimbraAdminConsoleUIComponents
# zimbraAdminSavedSearches
# zimbraDomainAdminMaxMailQuota
# zimbraFeatureAdminMailEnabled
# zimbraIsAdminAccount
# zimbraIsDelegatedAdminAccount
# zimbraIsDomainAdminAccount

### Archiving stuff
# zimbraArchiveAccount
# zimbraArchiveAccountDateTemplate
# zimbraArchiveAccountNameTemplate
# zimbraArchiveEnabled

### For resources
# zimbraAccountCalendarUserType

### Just shouldn't mess with it
# zimbraAuthTokenValidityValue
# zimbraAuthTokens
# zimbraCalendarCalDavSharedFolderCacheDuration
# zimbraCalendarCalDavSyncEnd
# zimbraCalendarCalDavSyncStart
# zimbraCalendarLocationDisabledFields
# zimbraCalendarMaxRevisions
# zimbraConverterHints
# zimbraCreateTimestamp
# zimbraCsrfTokenData
# zimbraDebugInfo
# zimbraLastLogonTimestamp
# zimbraLogOutFromAllServers
# zimbraMailIdleSessionTimeout
# zimbraMailboxLocationBeforeMove
# mail (managed by adding addresses, and domain admins might not have access)
# zimbraShareInfo
# zimbraShareLifetime
# zimbraSharedItem

### Like the above, but less so
### (just doesn't seem migration-appropriate)
# zimbraAvailableLocale
# zimbraAvailableSkin
# zimbraBatchedIndexingSize
# zimbraCOSId (will be different from system to system,
#              and if we automate CoS migration, we still
#              would be mangling this elsewhere)
# zimbraCalendarKeepExceptionsOnSeriesTimeChange
# zimbraCalendarShowResourceTabs
# zimbraContactMaxNumEntries - Affects resource usage,
#  almost belongs in "just shouldn't mess with it", but
#  some users go insane enough to hit this...
# zimbraContactRankingTableSize
# zimbraCustomerCareTier - ....uhhh what...?
# zimbraDataSourceCaldavPollingInterval
# zimbraDataSourceCalendarPollingInterval
# zimbraDataSourceGalPollingInterval
# zimbraDataSourceImapPollingInterval
# zimbraDataSourceLivePollingInterval
# zimbraDataSourceMinPollingInterval
# zimbraDataSourcePollingInterval
# zimbraDataSourcePop3PollingInterval
# zimbraDataSourceRssPollingInterval
# zimbraDataSourceYabPollingInterval
# zimbraDefaultFolderFlags
# zimbraExternalImapHostname
# zimbraExternalImapPort
# zimbraExternalImapSSLHostname
# zimbraExternalImapSSLPort
# zimbraExternalPop3Hostname
# zimbraExternalPop3Port
# zimbraExternalPop3SSLHostname
# zimbraExternalPop3SSLPort
# zimbraMailMessageLifetime
# zimbraMailSignatureMaxLength
# zimbraMailSpamLifetime
# zimbraMemberOf
# zimbraProxyAllowedDomains

### deprecated features
# zimbraChildAccount (8.5.0)
# zimbraChildVisibleAccount (8.5.)
# zimbraContactAutoCompleteEmailFields (6.0.7)
# These three don't say deprecated, but pretty sure they go with the google
# docs-esque "beta" functionality removed after 7.x.x
# zimbraFeatureBriefcaseSpreadsheetEnabled
# zimbraFeatureBriefcaseSlidesEnabled
# zimbraFeatureBriefcaseSpreadsheetEnabled

### Zimbra Community
# zimbraCommunityAPIClientID
# zimbraCommunityAPIClientSecret
# zimbraCommunityBaseURL
# zimbraCommunityHomeURL
# zimbraCommunityID
# zimbraCommunityUsernameMapping

### zimbraDevice features
# zimbraDeviceAllowedPasscodeLockoutDuration
# zimbraDeviceCalendarSoftDeleteExcludePattern
# zimbraDeviceFileOpenWithEnabled
# zimbraDeviceLockWhenInactive
# zimbraDeviceOfflineCacheEnabled
# zimbraDevicePasscodeEnabled
# zimbraDevicePasscodeLockoutDuration

### zimbraMobile
# zimbraMobileAttachSkippedItemEnabled
# zimbraMobileForceProtocol25
# zimbraMobileForceSamsungProtocol25
# zimbraMobileItemsToTrackPerFolderMaxSize
# zimbraMobileMetadataMaxSizeEnabled
# zimbraMobileNotificationAdminAddress
# zimbraMobileNotificationEnabled
# zimbraMobileOutlookSyncEnabled
# zimbraMobilePolicyAllowBluetooth
# zimbraMobilePolicyAllowBrowser
# zimbraMobilePolicyAllowCamera
# zimbraMobilePolicyAllowConsumerEmail
# zimbraMobilePolicyAllowDesktopSync
# zimbraMobilePolicyAllowHTMLEmail
# zimbraMobilePolicyAllowInternetSharing
# zimbraMobilePolicyAllowIrDA
# zimbraMobilePolicyAllowNonProvisionableDevices
# zimbraMobilePolicyAllowPOPIMAPEmail
# zimbraMobilePolicyAllowPartialProvisioning
# zimbraMobilePolicyAllowRemoteDesktop
# zimbraMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation
# zimbraMobilePolicyAllowSMIMESoftCerts
# zimbraMobilePolicyAllowSimpleDevicePassword
# zimbraMobilePolicyAllowStorageCard
# zimbraMobilePolicyAllowTextMessaging
# zimbraMobilePolicyAllowUnsignedApplications
# zimbraMobilePolicyAllowUnsignedInstallationPackages
# zimbraMobilePolicyAllowWiFi
# zimbraMobilePolicyAlphanumericDevicePasswordRequired
# zimbraMobilePolicyApprovedApplication
# zimbraMobilePolicyApprovedApplicationList
# zimbraMobilePolicyDeviceEncryptionEnabled
# zimbraMobilePolicyDevicePasswordEnabled
# zimbraMobilePolicyDevicePasswordExpiration
# zimbraMobilePolicyDevicePasswordHistory
# zimbraMobilePolicyMaxCalendarAgeFilter
# zimbraMobilePolicyMaxDevicePasswordFailedAttempts
# zimbraMobilePolicyMaxEmailAgeFilter
# zimbraMobilePolicyMaxEmailBodyTruncationSize
# zimbraMobilePolicyMaxEmailHTMLBodyTruncationSize
# zimbraMobilePolicyMaxInactivityTimeDeviceLock
# zimbraMobilePolicyMinDevicePasswordComplexCharacters
# zimbraMobilePolicyMinDevicePasswordLength
# zimbraMobilePolicyPasswordRecoveryEnabled
# zimbraMobilePolicyRefreshInterval
# zimbraMobilePolicyRequireDeviceEncryption
# zimbraMobilePolicyRequireEncryptedSMIMEMessages
# zimbraMobilePolicyRequireEncryptionSMIMEAlgorithm
# zimbraMobilePolicyRequireManualSyncWhenRoaming
# zimbraMobilePolicyRequireSignedSMIMEAlgorithm
# zimbraMobilePolicyRequireSignedSMIMEMessages
# zimbraMobilePolicyRequireStorageCardEncryption
# zimbraMobilePolicySuppressDeviceEncryption
# zimbraMobilePolicyUnapprovedInROMApplication
# zimbraMobileShareContactEnabled
# zimbraMobileSmartForwardRFC822Enabled
# zimbraMobileSyncKeyFormatConvertedFolders
# zimbraMobileSyncRedoMaxAttempts
# zimbraMobileTombstoneEnabled

### zimbraPassword
# zimbraPasswordAllowedChars
# zimbraPasswordAllowedPunctuationChars
# zimbraPasswordEnforceHistory
# zimbraPasswordHistory
# zimbraPasswordLocked
# zimbraPasswordLockoutDuration
# zimbraPasswordLockoutEnabled
# zimbraPasswordLockoutFailureLifetime
# zimbraPasswordLockoutFailureTime
# zimbraPasswordLockoutLockedTime
# zimbraPasswordLockoutMaxFailures
# zimbraPasswordMaxAge
# zimbraPasswordMaxLength
# zimbraPasswordMinAge
# zimbraPasswordMinAlphaChars
# zimbraPasswordMinDigitsOrPuncs
# zimbraPasswordMinLength
# zimbraPasswordMinLowerCaseChars
# zimbraPasswordMinNumericChars
# zimbraPasswordMinPunctuationChars
# zimbraPasswordMinUpperCaseChars
# zimbraPasswordModifiedTime
# zimbraPasswordMustChange

### Signature stuff
# zimbraPrefMailSignature
# zimbraPrefMailSignatureContactId
# zimbraPrefMailSignatureEnabled
# zimbraPrefMailSignatureHTML
# zimbraPrefMailSignatureStyle
# zimbraSignatureId
# zimbraSignatureMaxNumEntries
# zimbraSignatureMinNumEntries
# zimbraSignatureName
# zimbraPrefDefaultSignatureId
# zimbraPrefForwardReplySignatureId

### upsell attributes
# zimbraFeatureCalendarUpsellEnabled
# zimbraFeatureCalendarUpsellURL
# zimbraFeatureContactsUpsellEnabled
# zimbraFeatureContactsUpsellURL
# zimbraFeatureMailUpsellEnabled
# zimbraFeatureMailUpsellURL
# zimbraFeatureVoiceUpsellEnabled
# zimbraFeatureVoiceUpsellURL
# wtf, no briefcase upsell?

### Account attributes used for settings transfer
# I could potentially break these up (and then maybe even include some above stuff)
# But for now, these are what we look at, full stop...
zimbra_account_attributes = [ 'zimbraAccountStatus',
        # non-zimbra items
        'cn','co','company','description','facsimileTelephoneNumber',
        'givenName','homePhone','initials','l','mobile','ou','pager',
        'physicalDeliveryOfficeName','postalCode','sn','st','street',
        'telephoneNumber','title',
        # zimbra poilcy stuff
        'zimbraAllowAnyFromAddress','zimbraAllowFromAddress','zimbraAttachmentsBlocked',
        'zimbraAuthTokenLifetime', 'zimbraFeatureChangePasswordEnabled',
        'zimbraFeatureExportFolderEnabled', 'zimbraFeatureFiltersEnabled',
        'zimbraFeatureFlaggingEnabled', 'zimbraFeatureFreeBusyViewEnabled',
        'zimbraFeatureFromDisplayEnabled', 'zimbraFeatureGalAutoCompleteEnabled',
        'zimbraFeatureGalSyncEnabled', 'zimbraFeatureHtmlComposeEnabled',
        # ldap integration
        'zimbraAuthLdapExternalDn',
        # settings
        'zimbraAttachmentsViewInHtmlOnly','zimbraCalendarReminderDeviceEmail',
        'zimbraCalendarResourceDoubleBookingAllowed', 'zimbraExternalShareDomainWhitelistEnabled',
        'zimbraExternalShareLifetime', 'zimbraExternalShareWhitelistDomain',
        'zimbraExternalSharingEnabled', 'zimbraExternalUserMailAddress',
        'zimbraFeatureAntispamEnabled', 'zimbraFeatureCalendarReminderDeviceEmailEnabled',
        'zimbraFeatureComposeInNewWindowEnabled', 'zimbraFeatureConfirmationPageEnabled',
        'zimbraFeatureContactsDetailedSearchEnabled', 'zimbraFeatureCrocodocEnabled', # not sure about crocodoc either
        'zimbraFeatureDiscardInFiltersEnabled', 'zimbraFeatureDistributionListExpandMembersEnabled',
        'zimbraFeatureDistributionListFolderEnabled', 'zimbraFeatureExternalFeedbackEnabled',
        # dumpster
        'zimbraDumpsterEnabled', 'zimbraDumpsterPurgeEnabled',
        'zimbraDumpsterUserVisibleAge',
        # iffy settings
        'zimbraContactAutoCompleteMaxResults','zimbraContactEmailFields',
        # NE feature-level stuff
        'zimbraAttachmentsIndexingEnabled', 'zimbraExcludeFromCMBSearch',
        'zimbraFeatureAdvancedSearchEnabled', 'zimbraFeatureConversationsEnabled',
        'zimbraFeatureEwsEnabled', 'zimbraFeatureGalEnabled',
        'zimbraFeatureGroupCalendarEnabled', 'zimbraFeatureIMEnabled', # think im is deprecated, but maybe they're reusing for upcoming chat?
        'zimbraFeatureMAPIConnectorEnabled',
        # core features
        'zimbraFeatureBriefcasesEnabled', 'zimbraFeatureCalendarEnabled',
        'zimbraFeatureContactsEnabled', 'zimbraFeatureMailEnabled',
        # unsorted, but nothing damning
        'zimbraFeatureIdentitiesEnabled',
        'zimbraFeatureImapDataSourceEnabled',
        'zimbraFeatureImportExportFolderEnabled',
        'zimbraFeatureImportFolderEnabled',
        'zimbraFeatureInitialSearchPreferenceEnabled',
        'zimbraFeatureInstantNotify',
        'zimbraFeatureMailForwardingEnabled',
        'zimbraFeatureMailForwardingInFiltersEnabled',
        'zimbraFeatureMailPollingIntervalPreferenceEnabled',
        'zimbraFeatureMailPriorityEnabled',
        'zimbraFeatureMailSendLaterEnabled',
        'zimbraFeatureManageSMIMECertificateEnabled',
        'zimbraFeatureManageZimlets',
        'zimbraFeatureMobilePolicyEnabled',
        'zimbraFeatureMobileSyncEnabled',
        'zimbraFeatureNewAddrBookEnabled',
        'zimbraFeatureNewMailNotificationEnabled',
        'zimbraFeatureNotebookEnabled',
        'zimbraFeatureOpenMailInNewWindowEnabled',
        'zimbraFeatureOptionsEnabled',
        'zimbraFeatureOutOfOfficeReplyEnabled',
        'zimbraFeaturePeopleSearchEnabled',
        'zimbraFeaturePop3DataSourceEnabled',
        'zimbraFeaturePortalEnabled',
        'zimbraFeaturePriorityInboxEnabled',
        'zimbraFeatureReadReceiptsEnabled',
        'zimbraFeatureSMIMEEnabled',
        'zimbraFeatureSavedSearchesEnabled',
        'zimbraFeatureSharingEnabled',
        'zimbraFeatureShortcutAliasesEnabled',
        'zimbraFeatureSignaturesEnabled',
        'zimbraFeatureSkinChangeEnabled',
        'zimbraFeatureSocialEnabled',
        'zimbraFeatureSocialExternalEnabled',
        'zimbraFeatureSocialExternalURL',
        'zimbraFeatureSocialFiltersEnabled',
        'zimbraFeatureSocialName',
        'zimbraFeatureSocialcastEnabled',
        'zimbraFeatureTaggingEnabled',
        'zimbraFeatureTasksEnabled',
        'zimbraFeatureTouchClientEnabled',
        'zimbraFeatureViewInHtmlEnabled',
        'zimbraFeatureVoiceChangePinEnabled',
        'zimbraFeatureVoiceEnabled',
        'zimbraFeatureWebClientOfflineAccessEnabled',
        'zimbraFeatureWebSearchEnabled',
        'zimbraFeatureZimbraAssistantEnabled',
        'zimbraFileAndroidCrashReportingEnabled',
        'zimbraFileDeletionNotificationBody',
        'zimbraFileDeletionNotificationSubject',
        'zimbraFileExpirationWarningBody',
        'zimbraFileExpirationWarningSubject',
        'zimbraFileExpirationWarningThreshold',
        'zimbraFileExternalShareLifetime',
        'zimbraFileIOSCrashReportingEnabled',
        'zimbraFileLifetime',
        'zimbraFilePreviewMaxSize',
        'zimbraFilePublicShareLifetime',
        'zimbraFileShareLifetime',
        'zimbraFileUploadMaxSizePerFile',
        'zimbraFileVersionLifetime',
        'zimbraFileVersioningEnabled',
        'zimbraFilterBatchSize',
        'zimbraFilterSleepInterval',
        'zimbraForceClearCookies',
        'zimbraForeignPrincipal',
        'zimbraFreebusyExchangeAuthPassword',
        'zimbraFreebusyExchangeAuthScheme',
        'zimbraFreebusyExchangeAuthUsername',
        'zimbraFreebusyExchangeCachedInterval',
        'zimbraFreebusyExchangeCachedIntervalStart',
        'zimbraFreebusyExchangeURL',
        'zimbraFreebusyExchangeUserOrg',
        'zimbraFreebusyLocalMailboxNotActive',
        'zimbraGalSyncAccountBasedAutoCompleteEnabled',
        'zimbraIMAvailableInteropGateways',
        'zimbraIMService',
        'zimbraIdentityMaxNumEntries',
        'zimbraImapEnabled',
        'zimbraInterceptAddress',
        'zimbraInterceptBody',
        'zimbraInterceptFrom',
        'zimbraInterceptSendHeadersOnly',
        'zimbraInterceptSubject',
        'zimbraInternalSendersDomain',
        'zimbraIsCustomerCareAccount',
        'zimbraIsExternalVirtualAccount',
        'zimbraIsSystemAccount',
        'zimbraIsSystemResource',
        'zimbraJunkMessagesIndexingEnabled',
        'zimbraLocale',
        'zimbraMailAllowReceiveButNotSendWhenOverQuota',
        'zimbraMailBlacklistMaxNumEntries',
        'zimbraMailDumpsterLifetime',
        'zimbraMailForwardingAddressMaxLength',
        'zimbraMailForwardingAddressMaxNumAddrs',
        'zimbraMailHighlightObjectsMaxSize',
        'zimbraMailMinPollingInterval',
        'zimbraMailOutgoingSieveScript',
        'zimbraMailPurgeUseChangeDateForSpam',
        'zimbraMailPurgeUseChangeDateForTrash',
        'zimbraMailQuota',
        'zimbraMailSieveScript',
        'zimbraMailThreadingAlgorithm',
        'zimbraMailTrashLifetime',
        'zimbraMailTrustedSenderListMaxNumEntries',
        'zimbraMailWhitelistMaxNumEntries',
        'zimbraMaxContactsPerPage',
        'zimbraMaxMailItemsPerPage',
        'zimbraMaxVoiceItemsPerPage',
        'zimbraNewMailNotificationBody',
        'zimbraNewMailNotificationFrom',
        'zimbraNewMailNotificationSubject',
        'zimbraNotebookMaxRevisions',
        'zimbraNotebookSanitizeHtml',
        'zimbraNotes',
        'zimbraPhoneticCompany',
        'zimbraPhoneticFirstName',
        'zimbraPhoneticLastName',
        'zimbraPop3Enabled',
        'zimbraPortalName',
        'zimbraPrefAccountTreeOpen',
        'zimbraPrefAdminConsoleWarnOnExit',
        'zimbraPrefAdvancedClientEnforceMinDisplay',
        'zimbraPrefAllowAddressForDelegatedSender',
        'zimbraPrefAppleIcalDelegationEnabled',
        'zimbraPrefAutoAddAddressEnabled',
        'zimbraPrefAutoCompleteQuickCompletionOnComma',
        'zimbraPrefAutoSaveDraftInterval',
        'zimbraPrefAutocompleteAddressBubblesEnabled',
        'zimbraPrefBccAddress',
        'zimbraPrefBriefcaseReadingPaneLocation',
        'zimbraPrefCalendarAcceptSignatureId',
        'zimbraPrefCalendarAllowCancelEmailToSelf',
        'zimbraPrefCalendarAllowForwardedInvite',
        'zimbraPrefCalendarAllowPublishMethodInvite',
        'zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply',
        'zimbraPrefCalendarAlwaysShowMiniCal',
        'zimbraPrefCalendarApptAllowAtendeeEdit',
        'zimbraPrefCalendarApptReminderWarningTime',
        'zimbraPrefCalendarApptVisibility',
        'zimbraPrefCalendarAutoAcceptSignatureId',
        'zimbraPrefCalendarAutoAddInvites',
        'zimbraPrefCalendarAutoDeclineSignatureId',
        'zimbraPrefCalendarAutoDenySignatureId',
        'zimbraPrefCalendarDayHourEnd',
        'zimbraPrefCalendarDayHourStart',
        'zimbraPrefCalendarDeclineSignatureId',
        'zimbraPrefCalendarDefaultApptDuration',
        'zimbraPrefCalendarFirstDayOfWeek',
        'zimbraPrefCalendarForwardInvitesTo',
        'zimbraPrefCalendarInitialCheckedCalendars',
        'zimbraPrefCalendarInitialView',
        'zimbraPrefCalendarNotifyDelegatedChanges',
        'zimbraPrefCalendarReminderDeviceInfo',
        'zimbraPrefCalendarReminderDuration1',
        'zimbraPrefCalendarReminderDuration2',
        'zimbraPrefCalendarReminderEmail',
        'zimbraPrefCalendarReminderFlashTitle',
        'zimbraPrefCalendarReminderMobile',
        'zimbraPrefCalendarReminderSendEmail',
        'zimbraPrefCalendarReminderSoundsEnabled',
        'zimbraPrefCalendarReminderYMessenger',
        'zimbraPrefCalendarSendInviteDeniedAutoReply',
        'zimbraPrefCalendarShowDeclinedMeetings',
        'zimbraPrefCalendarShowPastDueReminders',
        'zimbraPrefCalendarTentativeSignatureId',
        'zimbraPrefCalendarToasterEnabled',
        'zimbraPrefCalendarUseQuickAdd',
        'zimbraPrefCalendarViewTimeInterval',
        'zimbraPrefCalendarWorkingHours',
        'zimbraPrefChildVisibleAccount',
        'zimbraPrefClientType',
        'zimbraPrefColorMessagesEnabled',
        'zimbraPrefComposeDirection',
        'zimbraPrefComposeFormat',
        'zimbraPrefComposeInNewWindow',
        'zimbraPrefContactsDisableAutocompleteOnContactGroupMembers',
        'zimbraPrefContactsExpandAppleContactGroups',
        'zimbraPrefContactsInitialView',
        'zimbraPrefContactsPerPage',
        'zimbraPrefConvReadingPaneLocation',
        'zimbraPrefConvShowCalendar',
        'zimbraPrefConversationOrder',
        'zimbraPrefDedupeMessagesSentToSelf',
        'zimbraPrefDefaultPrintFontSize',
        'zimbraPrefDelegatedSendSaveTarget',
        'zimbraPrefDeleteInviteOnReply',
        'zimbraPrefDisabledZimlets',
        'zimbraPrefDisplayExternalImages',
        'zimbraPrefExternalSendersType',
        'zimbraPrefFileSharingApplication',
        'zimbraPrefFolderColorEnabled',
        'zimbraPrefFolderTreeOpen',
        'zimbraPrefFont',
        'zimbraPrefFontSize',
        'zimbraPrefForwardIncludeOriginalText',
        'zimbraPrefForwardReplyFormat',
        'zimbraPrefForwardReplyInOriginalFormat',
        'zimbraPrefForwardReplyPrefixChar',
        'zimbraPrefFromAddress',
        'zimbraPrefFromAddressType',
        'zimbraPrefFromDisplay',
        'zimbraPrefGalAutoCompleteEnabled',
        'zimbraPrefGalSearchEnabled',
        'zimbraPrefGetMailAction',
        'zimbraPrefGroupMailBy',
        'zimbraPrefHtmlEditorDefaultFontColor',
        'zimbraPrefHtmlEditorDefaultFontFamily',
        'zimbraPrefHtmlEditorDefaultFontSize',
        'zimbraPrefIMAutoLogin',
        'zimbraPrefIMBuddyListSort',
        'zimbraPrefIMCustomStatusMessage',
        'zimbraPrefIMFlashIcon',
        'zimbraPrefIMFlashTitle',
        'zimbraPrefIMHideBlockedBuddies',
        'zimbraPrefIMHideOfflineBuddies',
        'zimbraPrefIMIdleStatus',
        'zimbraPrefIMIdleTimeout',
        'zimbraPrefIMInstantNotify',
        'zimbraPrefIMLogChats',
        'zimbraPrefIMLogChatsEnabled',
        'zimbraPrefIMNotifyPresence',
        'zimbraPrefIMNotifyStatus',
        'zimbraPrefIMReportIdle',
        'zimbraPrefIMSoundsEnabled',
        'zimbraPrefIMToasterEnabled',
        'zimbraPrefIMYahooId',
        'zimbraPrefIdentityName',
        'zimbraPrefImapSearchFoldersEnabled',
        'zimbraPrefInboxReadLifetime',
        'zimbraPrefInboxUnreadLifetime',
        'zimbraPrefIncludeSharedItemsInSearch',
        'zimbraPrefIncludeSpamInSearch',
        'zimbraPrefIncludeTrashInSearch',
        'zimbraPrefItemsPerVirtualPage',
        'zimbraPrefJunkLifetime',
        'zimbraPrefLabel',
        'zimbraPrefListViewColumns',
        'zimbraPrefLocale',
        'zimbraPrefMailDefaultCharset',
        'zimbraPrefMailFlashIcon',
        'zimbraPrefMailFlashTitle',
        'zimbraPrefMailFoldersCheckedForNewMsgIndicator',
        'zimbraPrefMailForwardingAddress',
        'zimbraPrefMailInitialSearch',
        'zimbraPrefMailItemsPerPage',
        'zimbraPrefMailLocalDeliveryDisabled',
        'zimbraPrefMailPollingInterval',
        'zimbraPrefMailRequestReadReceipts',
        'zimbraPrefMailSMIMECertificate',
        'zimbraPrefMailSelectAfterDelete',
        'zimbraPrefMailSendReadReceipts',
        'zimbraPrefMailSoundsEnabled',
        'zimbraPrefMailToasterEnabled',
        'zimbraPrefMailTrustedSenderList',
        'zimbraPrefMandatorySpellCheckEnabled',
        'zimbraPrefMarkMsgRead',
        'zimbraPrefMessageIdDedupingEnabled',
        'zimbraPrefMessageViewHtmlPreferred',
        'zimbraPrefNewMailNotificationAddress',
        'zimbraPrefNewMailNotificationEnabled',
        'zimbraPrefOpenMailInNewWindow',
        'zimbraPrefOutOfOfficeCacheDuration',
        'zimbraPrefOutOfOfficeDirectAddress',
        'zimbraPrefOutOfOfficeExternalReply',
        'zimbraPrefOutOfOfficeExternalReplyEnabled',
        'zimbraPrefOutOfOfficeFreeBusyStatus',
        'zimbraPrefOutOfOfficeFromDate',
        'zimbraPrefOutOfOfficeReply',
        'zimbraPrefOutOfOfficeReplyEnabled',
        'zimbraPrefOutOfOfficeStatusAlertOnLogin',
        'zimbraPrefOutOfOfficeSuppressExternalReply',
        'zimbraPrefOutOfOfficeUntilDate',
        'zimbraPrefPop3DeleteOption',
        'zimbraPrefPop3DownloadSince',
        'zimbraPrefPop3IncludeSpam',
        'zimbraPrefQuickCommand',
        'zimbraPrefReadReceiptsToAddress',
        'zimbraPrefReadingPaneEnabled',
        'zimbraPrefReadingPaneLocation',
        'zimbraPrefReplyIncludeOriginalText',
        'zimbraPrefReplyToAddress',
        'zimbraPrefReplyToDisplay',
        'zimbraPrefReplyToEnabled',
        'zimbraPrefSaveToSent',
        'zimbraPrefSearchTreeOpen',
        'zimbraPrefSentLifetime',
        'zimbraPrefSentMailFolder',
        'zimbraPrefSharedAddrBookAutoCompleteEnabled',
        'zimbraPrefShortEmailAddress',
        'zimbraPrefShortcuts',
        'zimbraPrefShowCalendarWeek',
        'zimbraPrefShowComposeDirection',
        'zimbraPrefShowFragments',
        'zimbraPrefShowSearchString',
        'zimbraPrefShowSelectionCheckbox',
        'zimbraPrefSkin',
        'zimbraPrefSortOrder',
        'zimbraPrefSpellDictionary',
        'zimbraPrefSpellIgnoreAllCaps',
        'zimbraPrefSpellIgnorePattern',
        'zimbraPrefSpellIgnoreWord',
        'zimbraPrefStandardClientAccessibilityMode',
        'zimbraPrefTagTreeOpen',
        'zimbraPrefTasksFilterBy',
        'zimbraPrefTasksReadingPaneLocation',
        'zimbraPrefTimeZoneId',
        'zimbraPrefTrashLifetime',
        'zimbraPrefUseDefaultIdentitySettings',
        'zimbraPrefUseKeyboardShortcuts',
        'zimbraPrefUseRfc2231',
        'zimbraPrefUseSendMsgShortcut',
        'zimbraPrefUseTimeZoneListInCalendar',
        'zimbraPrefVoiceItemsPerPage',
        'zimbraPrefWarnOnExit',
        'zimbraPrefWebClientOfflineBrowserKey',
        'zimbraPrefWhenInFolderIds',
        'zimbraPrefWhenInFoldersEnabled',
        'zimbraPrefWhenSentToAddresses',
        'zimbraPrefWhenSentToEnabled',
        'zimbraPrefZimletTreeOpen',
        'zimbraPrefZimlets',
        'zimbraPublicShareLifetime',
        'zimbraPublicSharingEnabled',
        'zimbraQuotaLastWarnTime',
        'zimbraQuotaWarnInterval',
        'zimbraQuotaWarnMessage',
        'zimbraQuotaWarnPercent',
        'zimbraReverseProxyUseExternalRoute',
        'zimbraSmtpEnableTrace',
        'zimbraSmtpRestrictEnvelopeFrom',
        'zimbraSocialcastURL',
        'zimbraSpamApplyUserFilters',
        'zimbraStandardClientCustomPrefTab',
        'zimbraStandardClientCustomPrefTabsEnabled',
        'zimbraSyncWindowSize',
        'zimbraTextAnalyzer',
        'zimbraTouchJSErrorTrackingEnabled',
        'zimbraTouchJSErrorTrackingKey',
        'zimbraUCPassword',
        'zimbraUCServiceId',
        'zimbraUCUsername',
        'zimbraVersion',
        'zimbraVirtualAccountInitialPasswordSet',
        'zimbraWebClientOfflineSyncMaxDays',
        'zimbraWebClientShowOfflineLink',
        'zimbraYahooId',
        'zimbraZimletAvailableZimlets',
        'zimbraZimletLoadSynchronously',
        'zimbraZimletUserProperties'
        ]

### left off: zimbraDebugInfo

def main(accounts):
    print("Migrating {0} accounts...".format(len(accounts)))
    for account in accounts:
        if re.match('^\s*#', account): continue
        print("Migrating {0}...".format(account))
        # imapsync
        if args.imapsync:
            print("\tPerforming imapsync...")
            imapsync(account)
        # signatures
        if args.signatures:
            print("\tSyncing signatures...")
            signatures(account)
        # account attributes
        if args.attrs:
            print("\tSyncing attributes...")
            attributes(account)
        # aliases
        if args.aliases:
            print("\tSyncing aliases...")
            account_aliases(account)
        # sharing (should go after calendars/contacts/briefacse)
        if args.sharing:
            print('\tSetting up shares...')
            sharing(account)
    # distribution lists
    if args.distlists:
        print('\tProvisioning distribution lists...')
        distlists()
    # calendar resources
    if args.resources:
        print("\tProvisioning calendar resources")
        resources()
    # aliases
    if args.aliases:
        print("\tSyncing non-account aliases...")
        distlist_aliases() 

### imapsync section

def imapsync(account):
    print("Beginning Mail Migration, getting mail-only folder list...")
    source_admin = _get_admin_session('Source')
    source_mail = _get_mail_session(source_admin, account, 'Source')
    response = source_mail.GetFolder(attributes = { 'visible':1, 'needGranteeName':'1' },
                                     folder     = {'value':'blah'})
    folders = []
    # go through every folder tag, we don't care the order/nesting
    for folder in response.folder:
        # External folder
        if f in folder and re.search(folder['f'], 'y'):
            continue
        if folder['absFolderPath'] is None:
            continue
        if folder['view'] in ['appointment','contact','document','task']:
            continue
        folder_name = re.sub(r'^/Inbox', '/INBOX', folder['absFolderPath'])
        folder_name = re.sub(r'^/', '', folder_name)
        folder_name = re.sub(r'&', '&-', folder_name)
        folders.append(folder_name)

    if args.verbose: print("Migrating folders: {0}".format(folders))

    imapsync = _gen_imapsync_command(account, folders)
    if args.no_changes:
        print("NO CHANGES: Not running imapsync, command would be:\n\t{0}".format(imapsync))
    else:
        print("Runnig imapsync command: {0}".format(imapsync))
        call(imapsync)

# imapsync helper function
def _gen_imapsync_command(account, folders):
    # Base imapsync command
    # 0 = imapsync full path
    # 1 = global imapsync options
    cmd = []
    cmd.append(config.get('Global', 'imapsync'))
    cmd = cmd + ast.literal_eval(config.get('Global', 'imapsync_opts'))

    # Source options
    cmd.append('--host1'); cmd.append(config.get('Source', 'zimbra_server'))
    cmd.append('--user1'); cmd.append(account)
    cmd.append('--authuser1'); cmd.append(config.get('Source', 'admin_user'))
    cmd.append('--password1'); cmd.append(config.get('Source', 'admin_pass'))
    cmd = cmd + ast.literal_eval(config.get('Source', 'imapsync_opts'))

    dest_account = _get_dest_address(account)

    # Dest options
    cmd.append('--host2'); cmd.append(config.get('Dest', 'zimbra_server'))
    cmd.append('--user2'); cmd.append(dest_account)
    cmd.append('--authuser2'); cmd.append(config.get('Dest', 'admin_user'))
    cmd.append('--password2'); cmd.append(config.get('Dest', 'admin_pass'))
    cmd = cmd + ast.literal_eval(config.get('Dest', 'imapsync_opts'))

    # Specify folders
    for folder in folders:
        cmd.append('--folder'); cmd.append(folder)

    cmd.append("2>&1")
    return cmd


### sigantures section
def signatures(account):
    source_admin = _get_admin_session('Source')
    source_mail  = _get_mail_session(source_admin, account, 'Source')

    dest_account = _get_dest_address(account)

    # Get admin login from dest server, and do delegate auth
    dest_admin = _get_admin_session('Dest')
    dest_mail = _get_mail_session(dest_admin, dest_account, 'Dest')
   
    source_mail.namespace = 'urn:zimbraAccount'
    sig_response = source_mail.GetSignatures()
    source_mail.namespace = 'urn:zimbraMail'

    #print sig_response.as_xml(pretty=True)
    if 'signature' not in sig_response:
        print("\tNo signatures to sync")
        return 1
    for sig in sig_response.signature:
        print("Syncing signature: {0}".format(sig['name']))
        source_cid = None
        dest_cid = None
        children = sig.children()
        for child in (children or []):
            # Find if contact has cid tag
            if child.get_name() == 'cid':
                source_cid = str(child)

        # If we have a cid tag, we need to determine which contact it
        # is so we can find the corresponding contact on the dest server
        if source_cid:
            source_contact = source_mail.GetContacts(cn = {'id':source_cid, 'value':''}).cn
            source_contact_folderid = source_contact['l']
            source_contact_folder = source_mail.GetFolder(attributes = {'depth':'0'},
                                                              folder = {'l':source_contact_folderid, 'value':''}).folder
            dest_mail.namespace = 'urn:zimbraMail'
            dest_contacts = dest_mail.Search(attributes = {'types':'contact'},
                                                  query = {'value':'in:"{0}" contact:"{1}"'.format(source_contact_folder['absFolderPath'], source_contact['fileAsStr'])})

            # if we've found our contact, set dest_cid to that
            # TODO: Deep check of contact match in case of multiple contacts with same name
            if 'cn' in dest_contacts:
                for cn in dest_contacts.cn:
                    if cn['fileAsStr'] == source_contact['fileAsStr']:
                        dest_cid = cn['id']

        # del sig.cid doesn't do what you'd expect (removes all children)
        # don't know of any intended way to do this, so digging into internals...
        if source_cid:
            sig._element.removeChild(sig.cid._element)
        if dest_cid:
            sig.cid = dest_cid
        
        if args.no_changes:
            print("NO CHANGES: Not syncing sig, SOAP command would be:\n\t<CreateSignatureRequest>{0}</CreateSignatureRequest>".format(sig.__repr__()))
            continue

        try:
            dest_mail.namespace = 'urn:zimbraAccount'
            dest_sigs = dest_mail.GetSignatures()
            if 'signature' in dest_sigs:
                for sig_iter in dest_sigs.signature:
                    if sig_iter['name'] == sig['name']:
                        dest_mail.DeleteSignature(signature = {'name':sig['name'], 'value':''})
            dest_mail.CreateSignature(sig)
        except pysimplesoap.client.SoapFault as e:
            # If signature already exists, sweet!
            if re.search('signature already exists', str(e)):
                continue
            else:
                raise

### account attributes
def attributes(account):
    print("Beginning account preference migration...")
    # Get admin logins
    source_admin = _get_admin_session('Source')
    dest_account = _get_dest_address(account)
    dest_admin = _get_admin_session('Dest')

    source_attrs = source_admin.ParseAttributes(source_admin.GetAccount(account = {'by':'name', 'value':account}, attributes = {'applyCos':'0'}).a)
    dest_attrs = dest_admin.ParseAttributes(dest_admin.GetAccount(account = {'by':'name', 'value':dest_account}, attributes = {'applyCos':'0'}).a)

    # List of attributes we don't have access to
    bl_source_attrs = _get_blacklisted_attrs(source_admin.GetAccount(account = {'by':'name', 'value':account}, attributes = {'applyCos':'1'}).a)
    bl_dest_attrs = _get_blacklisted_attrs(dest_admin.GetAccount(account = {'by':'name', 'value':dest_account}, attributes = {'applyCos':'1','attrs':','.join(zimbra_account_attributes)}).a)

    final_attrs = []

    for attr in source_attrs:
        if attr in zimbra_account_attributes:
            # We don't want stuff that is set on dest that is showing up as
            # blank due to access on source to be unset
            # Zimbra really responds by putting pd=1 in the <a> tag,
            # should probably switch to looking there...
            if attr in bl_source_attrs:
                print("\tWARNING: No access to attribute {0} (\"{1}\") on source account, ignoring...".format(attr, source_attrs[attr]))
                continue
            if attr in bl_dest_attrs:
                print("\tWARNING: No access to attribute {0} (\"{1}\") on destination account, ignoring...".format(attr, source_attrs[attr]))
                continue
            if source_attrs[attr][0] == '':
                continue
            if attr not in dest_attrs:
                print("\t{0}: {1} -> ''".format(attr, source_attrs[attr]))
                for value in source_attrs[attr]:
                    final_attrs.append({'n':attr, 'value':value})
            elif attr not in dest_attrs or source_attrs[attr] != dest_attrs[attr]:
                print("\t{0}: {1} -> {2}".format(attr, source_attrs[attr], dest_attrs[attr]))
                for value in source_attrs[attr]:
                    final_attrs.append({'n':attr, 'value':value})
    
    # print modify_account.as_xml(pretty=True)
    if args.no_changes:
        print("NO CHANGES: Not modifying account...")
        return
    
    dest_admin.ModifyAccount(id = dest_attrs['zimbraId'][0], a = final_attrs)

### aliases
def account_aliases(account):
    print("Beginning alias migration...")
    # Get admin logins
    source_admin = _get_admin_session('Source')
    dest_account = _get_dest_address(account)
    dest_admin = _get_admin_session('Dest')

    source_attrs = source_admin.ParseAttributes(source_admin.GetAccount(account = {'by':'name', 'value':account}, attributes = {'applyCos':'0'}).a)
    dest_attrs = dest_admin.ParseAttributes(dest_admin.GetAccount(account = {'by':'name', 'value':dest_account}, attributes = {'applyCos':'0'}).a)

    if 'zimbraMailAlias' in source_attrs:
        for alias in source_attrs['zimbraMailAlias']:
            print("\t{0} has alias: {1}".format(account, alias))
            if args.no_changes:
                print("NO CHANGES: Not adding alias...")
                continue
            dest_alias = _get_dest_address(alias)
            if 'zimbraMailAlias' in dest_attrs and dest_alias in dest_attrs['zimbraMailAlias']:
                if args.verbose: print("\tAlias {0} already on account!".format(dest_alias))
                continue
            dest_admin.AddAccountAlias(id = {'value':dest_attrs['zimbraId'][0]}, alias = {'value':dest_alias})

### distribution list aliases
def distlist_aliases():
    source_admin = _get_admin_session('Source')
    dest_admin = _get_admin_session('Dest')

    lists = source_admin.GetAllDistributionLists(domain = {'by':'name', 'value':config.get('Source', 'domain')})
    #print lists.as_xml(pretty=True)

    for dl in lists.dl:
        print("\n\tChecking list {0}".format(dl['name']))
        source_data = source_admin.GetDistributionList(dl = {'by':'name', 'value':dl['name']})
        #print source_data.as_xml(pretty=True)

        try:
            dest_address = _get_dest_address(dl['name'])
            dest_data = dest_admin.GetDistributionList(dl = {'by':'name', 'value':dest_address})
        except pysimplesoap.client.SoapFault as e:
            if re.search('no such distribution list', str(e)):
                print("\tERROR: No such distribution list: {0}...\n".format(dest_address))
            else:
                raise
        dest_attrs = dest_admin.ParseAttributes(dest_data.a)

        dest_aliases = []
        for a in dest_data.dl.a:
            if a['n'] == 'zimbraMailAlias':
                if a['pd']:
                    print("\tERROR: No access to distribution list attribute!")
                else:
                    dest_aliases.append(str(a))

        for a in source_data.dl.a:
            if a['n'] == 'zimbraMailAlias':
                if a['pd']:
                    print("\tERROR: No access to distribution list attribute!")
                    continue
                dest_alias = _get_dest_address(str(a))
                if dest_alias == dest_address:
                    #print("\tNot an alias (account name)")
                    continue
                elif dest_alias in dest_aliases:
                    if args.verbose: print("\tAlias {0} already provisioned".format(a))
                else:
                    print("\tList has alias: {0}".format(a))
                    if args.no_changes:
                        print("NO CHANGES: Not modifying distribution list...")
                    else:
                        dest_admin.AddDistributionListAlias(id = {'value':dest_attrs['zimbraId'][0]}, alias = {'value':dest_alias})



### sharing section
def sharing(account):
    print("Beginning shared folder Migration...")
    # Get admin login from source server, and do delegate auth
    source_admin = _get_admin_session('Source')
    source_mail = _get_mail_session(source_admin, account, 'Source')

    dest_account = _get_dest_address(account)

    # Get admin login from dest server, and do delegate auth
    dest_admin = _get_admin_session('Dest')
    dest_mail = _get_mail_session(dest_admin, dest_account, 'Dest')


    folders = source_mail.GetFolder(attributes = { 'visible':1, 'needGranteeName':'1' },
                                     folder     = {'value':'blah'})

    for folder in folders.folder:
        children = folder.children()
        for child in (children or []):
            if child.get_name() == 'acl' and 'grant' in folder.acl:
                for grant in folder.acl.grant:
                    # Get dest folder ida
                    try:
                        dest_folder = dest_mail.GetFolder(folder = {'depth':'0', 'value':'', 'path':folder['absFolderPath']}).folder
                    except pysimplesoap.client.SoapFault as e:
                        # If original folder was empty, it may not have been migrated
                        if re.search('no such folder path', str(e)) and folder['n'] == '0':
                            print('{0}:'.format(folder['absFolderPath']))
                            print("\tDestination folder DOES NOT EXIST, but source is empty! Skipping...")
                            continue
                    if grant['gt'] == 'usr' or grant['gt'] == 'dom':
                        # Check if we're migrating to a different domain
                        if config.has_option('Dest', 'domain'):
                            domain = re.match('.*@(.*)', account)
                            target_name = re.sub(domain.group(1), config.get('Dest', 'domain'), grant['d'])
                        else:
                            target_name = grant['d']
                        print("{0} [{4} > {5}] -- grantor: {1} -- grantee: {2} [{3}]".format(folder['absFolderPath'], dest_account, target_name, grant['perm'], folder['id'], dest_folder['id']))
                        _add_share(dest_mail, dest_folder['id'], grant['gt'], target_name, grant['perm'])
                    elif grant['gt'] == 'guest':
                        print("{0} [{4} > {5}] -- grantor: {1} -- grantee: {2} [{3}]".format(folder['absFolderPath'], dest_account, grant['zid'], grant['perm'], folder['id'], dest_folder['id']))
                        _add_share(dest_mail, dest_folder['id'], grant['gt'], grant['zid'], grant['perm'])
                    else:
                        print("Unknown grant type!!!")
                        exit(0)
        #if 'acl' in folder and 'grant' in folder.acl:

# sharing helper function
def _add_share(mail, folder_id, target_type, target_name, perm):
    if args.no_changes:
        print("NO CHANGES: Not adding share...\n")
        return 1
    try:
        result = mail.FolderAction(action = {'op':'grant', 'id':folder_id, 'value':{'grant':{'value':'', 'perm':perm, 'd':target_name, 'gt':target_type} }})
    except pysimplesoap.client.SoapFault as e:
        # We're good!
        if re.search('grantee already exists', str(e)):
            print("\tGrant already exists. Continuing...")
            return 1
        else:
            raise
    return result

### distribution lists
def distlists():
    source_admin = _get_admin_session('Source')
    dest_admin = _get_admin_session('Dest')

    lists = source_admin.GetAllDistributionLists(domain = {'by':'name', 'value':config.get('Source', 'domain')})
    #print lists.as_xml(pretty=True)

    distlist_attrs = ['zimbraMailStatus', 'cn', 'zimbraHideInGal', 'description', 'displayName']
    distlist_attr_bl = ['uid', 'mail', 'zimbraId', 'zimbraMailAlias', 'zimbraIsAdminGroup']

    for dl in lists.dl:
        print("\n\tProvisioning {0}".format(dl['name']))
        source_data = source_admin.GetDistributionList(dl = {'by':'name', 'value':dl['name']})
        #print source_data.as_xml(pretty=True)

        try:
            dest_address = _get_dest_address(dl['name'])
            dest_data = dest_admin.GetDistributionList(dl = {'by':'name', 'value':dest_address})
        except pysimplesoap.client.SoapFault as e:
            if re.search('no such distribution list', str(e)):
                print("Creating list {0}...".format(dest_address))
                if args.no_changes:
                    print("NO CHANGES: Not creating distribution list...")
                else:
                    print("Creating distribution list {0}...".format(dest_address))
                    dest_data = dest_admin.CreateDistributionList(attributes = {'dynamic':dl['dynamic']}, name = {'value':dest_address })
            else:
                raise
        dest_attrs = dest_admin.ParseAttributes(dest_data.a)

        for dl in source_data.dl:
            #print dest_data.as_xml(pretty=True)
            modify_list = pysimplesoap.simplexml.SimpleXMLElement('<ModifyDistributionListRequest><id>{0}</id></ModifyDistributionListRequest>'.format(dest_data.dl['id']))
            for a in dl.a:
                if a['pd']:
                    continue
                elif a['n'] in distlist_attrs:
                    if a['n'] in dest_attrs and str(a) != dest_attrs[a['n']][0]:
                        print("\t{0}: {1} -> {2}".format(a['n'], a, dest_attrs[a['n']][0]))
                        child = modify_list.add_child('a', a)
                        child['n'] = a['n']
                elif a['n'] in distlist_attr_bl:
                    continue
                else:
                    print("Don't know what to do with {0}!".format(a['n']))
            #print modify_list.as_xml(pretty=True)
            if args.no_changes:
                print("NO CHANGES: Not modifying distribution list...")
            else:
                dest_admin.do_req('ModifyDistributionListRequest', modify_list)

            add_members =  pysimplesoap.simplexml.SimpleXMLElement('<AddDistributionListMemberRequest><id>{0}</id></AddDistributionListMemberRequest>'.format(dest_data.dl['id']))
            if 'dlm' in source_data.dl:
                for member in source_data.dl.dlm:
                    if _member_not_in_list(dest_data, str(member)):
                        print("\tMember: {0}".format(member))
                        add_members.add_child('dlm', str(member))

        try:
            print("Adding members...")
            if args.no_changes:
                print("NO CHANGES: Not adding members...")
                continue
            # no members to add
            if 'dlm' not in add_members:
                continue
            dest_admin.do_req('AddDistributionListMemberRequest', add_members)
        except  pysimplesoap.client.SoapFault as e:
            raise

def _member_not_in_list(dest_data, member):
    if 'dlm' in dest_data.dl:
        for dest_member in dest_data.dl.dlm:
            if str(dest_member) == member:
                return False
    return True

### resources
def resources():
    # This will remain TODO for now
    # Domain I'm migrating doesn't have any resources
    source_admin = _get_admin_session('Source')
    dest_admin = _get_admin_session('Dest')

    resources = source_admin.GetAllCalendarResources(domain = {'by':'name', 'value':config.get('Source', 'domain')})

    print(resources.as_xml(pretty=True))
    print("Resources not in script yet!!")
    exit(1)

### global helper functions
def _get_dest_address(account):
    # Check if we're migrating to a different domain
    if config.has_option('Dest', 'domain'):
        local_part = re.match('(.*)@.*', account)
        return "{0}@{1}".format(local_part.group(1), config.get('Dest', 'domain'))
    else:
        return account

def _get_blacklisted_attrs(attrs):
    bl_attrs = []
    for a in attrs:
        if a['pd']:
            bl_attrs.append(a['n'])
    return bl_attrs

def _get_admin_session(section):
    source_admin = zimbrasoap.admin(server  = config.get(section, 'admin_server'),
                                    trace   = args.debug,
                                    verbose = args.verbose)
    source_admin.Auth(name     = config.get(section, 'admin_user'),
                      password = config.get(section, 'admin_pass'))
    return source_admin

def _get_mail_session(admin, account, section):
    response = admin.GetAccountInfo(account = {'by':'name', 'value':account})
    zimbraId = admin.ParseAttributes(response.a)['zimbraId'][0]
    response = admin.DelegateAuth(attributes = { 'duration':'86400' }, account = {'by':'id', 'value':zimbraId})
    mail = zimbrasoap.mail(server = config.get(section, 'zimbra_server'),
                           authToken = response.authToken,
                           authTokenLifetime = response.lifetime,
                           zimbraId = zimbraId, trace = args.debug, verbose = args.verbose)
    if args.ssl_level:
        if args.ssl_level == 'ssl3': ssl_level = ssl.PROTOCOL_SSLv3
        elif args.ssl_level == 'tls1': ssl_level = ssl.PROTOCOL_TLSv1
        elif args.ssl_level == 'tls1.1': ssl_level = ssl.PROTOCOL_TLSv1_1
        elif args.ssl_level == 'tls1.2': ssl_level = ssl.PROTOCOL_TLSv1_2
        mail.set_ssl(ssl_level)
    return mail

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Zimbra to Zimbra Migration Helper')
    parser.add_argument('-c', '--config', default='zmigrator.cfg', help='Config file (default: zmigrator.cfg)')
    parser.add_argument('-l', '--list', default='list.txt', help='Account list')
    parser.add_argument('-d', '--debug', action='store_true', help='Debug mode (SOAP Trace)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose mode')
    parser.add_argument('-n', '--no_changes', action='store_true', help='No changes (dry run)')
    parser.add_argument('--ssl_level', help='ssl/tls level (ssl3/tls1/tls1.1/tls1.2)')
    parser.add_argument('--imapsync', action='store_true', help='Perform imapsyncs')
    parser.add_argument('--signatures', action='store_true', help='Signatures')
    parser.add_argument('--attrs', action='store_true', help='Account Attributes')
    parser.add_argument('--aliases', action='store_true', help='Aliases')
    parser.add_argument('--distlists', action='store_true', help='Distribution Lists')
    parser.add_argument('--resources', action='store_true', help='Calendar Resources')
    parser.add_argument('--sharing', action='store_true', help='Sharing (should be the last thing)')
    args = parser.parse_args()

    config.read(args.config)

    if not config.has_option('Global', 'imapsync'):
        config.set('Global', 'imapsync', 'imapsync')
    if not config.has_option('Global', 'imapsync_opts'):
        config.set('Global', 'imapsync_opts', '')
    if not config.has_option('Source', 'admin_server'):
        config.set('Source', 'admin_server', config.get('Source', 'zimbra_server'))
    if not config.has_option('Source', 'imapsync_opts'):
        config.set('Source', 'imapsync_opts', '')
    if not config.has_option('Dest', 'admin_server'):
        config.set('Dest', 'admin_server', config.get('Dest', 'zimbra_server'))
    if not config.has_option('Dest', 'imapsync_opts'):
        config.set('Dest', 'imapsync_opts', '[]')

    with open(args.list) as f:
        accounts = f.read().splitlines()

    main(accounts)
