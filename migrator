#!/usr/bin/python
import re
import ast
import argparse
import ConfigParser
import httplib2
from subprocess import call

import pysimplesoap
import zimbrasoap

config = ConfigParser.RawConfigParser()
args = ''

### Ripped from stackoverflow
### Current host I'm working with borks on tls negotiations supporting 1.2
# Start of the workaround for SSL3
# This is a monkey patch / module function overriding
# to allow pages that only work with SSL3

# Build the appropriate socket wrapper for ssl
try:
    import ssl # python 2.6
    httplib2.ssl_SSLError = ssl.SSLError
    def _ssl_wrap_socket(sock, key_file, cert_file,
                         disable_validation, ca_certs):
        if disable_validation:
            cert_reqs = ssl.CERT_NONE
        else:
            cert_reqs = ssl.CERT_REQUIRED
        # Our fix for sites the only accepts SSL3
        try:
            # Trying SSLv3 first
            tempsock = ssl.wrap_socket(sock, keyfile=key_file, certfile=cert_file,
                                       cert_reqs=cert_reqs, ca_certs=ca_certs,
                                       ssl_version=ssl.PROTOCOL_TLSv1)
        except ssl.SSLError, e:
            tempsock = ssl.wrap_socket(sock, keyfile=key_file, certfile=cert_file,
                                       cert_reqs=cert_reqs, ca_certs=ca_certs,
                                       ssl_version=ssl.PROTOCOL_TLSv1)
        return tempsock
    httplib2._ssl_wrap_socket = _ssl_wrap_socket
except (AttributeError, ImportError):
    httplib2.ssl_SSLError = None
    def _ssl_wrap_socket(sock, key_file, cert_file,
                         disable_validation, ca_certs):
        if not disable_validation:
            raise httplib2.CertificateValidationUnsupported(
                    "SSL certificate validation is not supported without "
                    "the ssl module installed. To avoid this error, install "
                    "the ssl module, or explicity disable validation.")
        ssl_sock = socket.ssl(sock, key_file, cert_file)
        return httplib.FakeSocket(sock, ssl_sock)
    httplib2._ssl_wrap_socket = _ssl_wrap_socket

# End of the workaround for SSL3

def main(accounts):
    print("Migrating {0} accounts...".format(len(accounts)))
    for account in accounts:
        if re.match('^\s*#', account): continue
        print("Migrating {0}...".format(account))
        # imapsync
        if args.imapsync:
            print("\tPerforming imapsync...")
            imapsync(account)
        # signatures
        if args.signatures:
            print("\tSyncing signatures...")
            signatures(account)
        # sharing (should go after calendars/contacts/briefacse)
        if args.sharing:
            print('\tSetting up shares...')
            sharing(account)

### imapsync section

def imapsync(account):
    print("Beginning Mail Migration, getting mail-only folder list...")
    source_admin = _get_admin_session('Source')
    source_mail = _get_mail_session(source_admin, account, 'Source')
    response = source_mail.GetFolder(attributes = { 'visible':1, 'view':'message', 'needGranteeName':'1' },
                                     folder     = {'value':'blah'})
    folders = []
    # go through every folder tag, we don't care the order/nesting
    for folder in response.folder:
        # External folder
        if f in folder and re.search(folder['f'], 'y'):
            continue
        if folder['absFolderPath'] is None:
            continue
        folder_name = re.sub(r'^/Inbox', '/INBOX', folder['absFolderPath'])
        folder_name = re.sub(r'^/', '', folder_name)
        folder_name = re.sub(r'&', '&-', folder_name)
        folders.append(folder_name)

    if args.verbose: print("Migrating folders: {0}".format(folders))

    imapsync = _gen_imapsync_command(account, folders)
    if args.no_changes:
        print("NO CHANGES: Not running imapsync, command would be:\n\t{0}".format(imapsync))
    else:
        print("Runnig imapsync command: {0}".format(imapsync))
        call(imapsync)

# imapsync helper function
def _gen_imapsync_command(account, folders):
    # Base imapsync command
    # 0 = imapsync full path
    # 1 = global imapsync options
    cmd = []
    cmd.append(config.get('Global', 'imapsync'))
    cmd = cmd + ast.literal_eval(config.get('Global', 'imapsync_opts'))

    # Source options
    cmd.append('--host1'); cmd.append(config.get('Source', 'zimbra_server'))
    cmd.append('--user1'); cmd.append(account)
    cmd.append('--authuser1'); cmd.append(config.get('Source', 'admin_user'))
    cmd.append('--password1'); cmd.append(config.get('Source', 'admin_pass'))
    cmd = cmd + ast.literal_eval(config.get('Source', 'imapsync_opts'))

    dest_account = _get_dest_address(account)

    # Dest options
    cmd.append('--host2'); cmd.append(config.get('Dest', 'zimbra_server'))
    cmd.append('--user2'); cmd.append(dest_account)
    cmd.append('--authuser2'); cmd.append(config.get('Dest', 'admin_user'))
    cmd.append('--password2'); cmd.append(config.get('Dest', 'admin_pass'))
    cmd = cmd + ast.literal_eval(config.get('Dest', 'imapsync_opts'))

    # Specify folders
    for folder in folders:
        cmd.append('--folder'); cmd.append(folder)

    cmd.append("2>&1")
    return cmd


### sigantures section
def signatures(account):
    source_admin = _get_admin_session('Source')
    source_mail  = _get_mail_session(source_admin, account, 'Source')

    dest_account = _get_dest_address(account)

    # Get admin login from dest server, and do delegate auth
    dest_admin = _get_admin_session('Dest')
    dest_mail = _get_mail_session(dest_admin, dest_account, 'Dest')
   
    source_mail.namespace = 'urn:zimbraAccount'
    sig_response = source_mail.GetSignatures()
    source_mail.namespace = 'urn:zimbraMail'

    #print sig_response.as_xml(pretty=True)
    if 'signature' not in sig_response:
        print("\tNo signatures to sync")
        return 1
    for sig in sig_response.signature:
        print("Syncing signature: {0}".format(sig['name']))
        source_cid = None
        dest_cid = None
        children = sig.children()
        for child in (children or []):
            # Find if contact has cid tag
            if child.get_name() == 'cid':
                source_cid = str(child)

        # If we have a cid tag, we need to determine which contact it
        # is so we can find the corresponding contact on the dest server
        if source_cid:
            source_contact = source_mail.GetContacts(cn = {'id':source_cid, 'value':''}).cn
            source_contact_folderid = source_contact['l']
            source_contact_folder = source_mail.GetFolder(attributes = {'depth':'0'},
                                                              folder = {'l':source_contact_folderid, 'value':''}).folder
            dest_mail.namespace = 'urn:zimbraMail'
            dest_contacts = dest_mail.Search(attributes = {'types':'contact'},
                                                  query = {'value':'in:"{0}" contact:"{1}"'.format(source_contact_folder['absFolderPath'], source_contact['fileAsStr'])})

            # if we've found our contact, set dest_cid to that
            # TODO: Deep check of contact match in case of multiple contacts with same name
            if 'cn' in dest_contacts:
                for cn in dest_contacts.cn:
                    if cn['fileAsStr'] == source_contact['fileAsStr']:
                        dest_cid = cn['id']

        # del sig.cid doesn't do what you'd expect (removes all children)
        # don't know of any intended way to do this, so digging into internals...
        if source_cid:
            sig._element.removeChild(sig.cid._element)
        if dest_cid:
            sig.cid = dest_cid
        
        if args.no_changes:
            print("NO CHANGES: Not syncing sig, SOAP command would be:\n\t<CreateSignatureRequest>{0}</CreateSignatureRequest>".format(sig.__repr__()))
            continue

        try:
            dest_mail.namespace = 'urn:zimbraAccount'
            dest_sigs = dest_mail.GetSignatures()
            for sig_iter in dest_sigs.signature:
                if sig_iter['name'] == sig['name']:
                    dest_mail.DeleteSignature(signature = {'name':sig['name'], 'value':''})
            dest_mail.CreateSignature(sig)
        except pysimplesoap.client.SoapFault, e:
            # If signature already exists, sweet!
            if re.search('signature already exists', str(e)):
                continue
            else:
                raise


### sharing section

def sharing(account):
    print("Beginning Mail Migration, getting mail-only folder list...")
    # Get admin login from source server, and do delegate auth
    source_admin = _get_admin_session('Source')
    source_mail = _get_mail_session(source_admin, account, 'Source')

    dest_account = _get_dest_address(account)

    # Get admin login from dest server, and do delegate auth
    dest_admin = _get_admin_session('Dest')
    dest_mail = _get_mail_session(dest_admin, dest_account, 'Dest')


    folders = source_mail.GetFolder(attributes = { 'visible':1, 'needGranteeName':'1' },
                                     folder     = {'value':'blah'})

    for folder in folders.folder:
        children = folder.children()
        for child in (children or []):
            if child.get_name() == 'acl' and 'grant' in folder.acl:
                for grant in folder.acl.grant:
                    # Get dest folder ida
                    try:
                        dest_folder = dest_mail.GetFolder(folder = {'depth':'0', 'value':'', 'path':folder['absFolderPath']}).folder
                    except pysimplesoap.client.SoapFault, e:
                        # If original folder was empty, it may not have been migrated
                        if re.search('no such folder path', str(e)) and folder['n'] == '0':
                            print('{0}:'.format(folder['absFolderPath']))
                            print("\tDestination folder DOES NOT EXIST, but source is empty! Skipping...")
                            continue
                    if grant['gt'] == 'usr' or grant['gt'] == 'dom':
                        # Check if we're migrating to a different domain
                        if config.has_option('Dest', 'domain'):
                            domain = re.match('.*@(.*)', account)
                            target_name = re.sub(domain.group(1), config.get('Dest', 'domain'), grant['d'])
                        else:
                            target_name = grant['d']
                        print("{0} [{4} > {5}] -- grantor: {1} -- grantee: {2} [{3}]".format(folder['absFolderPath'], dest_account, target_name, grant['perm'], folder['id'], dest_folder['id']))
                        _add_share(dest_mail, dest_folder['id'], grant['gt'], target_name, grant['perm'])
                    elif grant['gt'] == 'guest':
                        print("{0} [{4} > {5}] -- grantor: {1} -- grantee: {2} [{3}]".format(folder['absFolderPath'], dest_account, grant['zid'], grant['perm'], folder['id'], dest_folder['id']))
                        _add_share(dest_mail, dest_folder['id'], grant['gt'], grant['zid'], grant['perm'])
                    else:
                        print("Unknown grant type!!!")
                        exit(0)
        #if 'acl' in folder and 'grant' in folder.acl:

# sharing helper function
def _add_share(mail, folder_id, target_type, target_name, perm):
    if args.no_changes:
        print("NO CHANGES: Not adding share...\n")
        return 1
    try:
        result = mail.FolderAction(action = {'op':'grant', 'id':folder_id, 'value':{'grant':{'value':'', 'perm':perm, 'd':target_name, 'gt':target_type} }})
    except pysimplesoap.client.SoapFault, e:
        # We're good!
        if re.search('grantee already exists', str(e)):
            print("\tGrant already exists. Continuing...")
            return 1
        else:
            raise
    return result

### global helper functions
def _get_dest_address(account):
    # Check if we're migrating to a different domain
    if config.has_option('Dest', 'domain'):
        local_part = re.match('(.*)@.*', account)
        return "{0}@{1}".format(local_part.group(1), config.get('Dest', 'domain'))
    else:
        return account

def _get_admin_session(section):
    source_admin = zimbrasoap.admin(server  = config.get(section, 'admin_server'),
                                    debug   = args.debug,
                                    verbose = args.verbose)
    source_admin.Auth(name     = config.get(section, 'admin_user'),
                      password = config.get(section, 'admin_pass'))
    return source_admin

def _get_mail_session(admin, account, section):
    response = admin.GetAccountInfo(account = {'by':'name', 'value':account})
    zimbraId = admin.ParseAttributes(response.a)['zimbraId'][0]
    response = admin.DelegateAuth(attributes = { 'duration':'86400' }, account = {'by':'id', 'value':zimbraId})
    mail = zimbrasoap.mail(server = config.get(section, 'zimbra_server'),
                           authToken = response.authToken,
                           authTokenLifetime = response.lifetime,
                           zimbraId = zimbraId, debug = args.debug, verbose = args.verbose)
    return mail

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Zimbra to Zimbra Migration Helper')
    parser.add_argument('-c', '--config', default='zmigrator.cfg', help='Config file (default: zmigrator.cfg)')
    parser.add_argument('-l', '--list', default='list.txt', help='Account list')
    parser.add_argument('-d', '--debug', action='store_true', help='Debug mode (SOAP Trace)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose mode')
    parser.add_argument('-n', '--no_changes', action='store_true', help='No changes (dry run)')
    parser.add_argument('--imapsync', action='store_true', help='Perform imapsyncs')
    parser.add_argument('--signatures', action='store_true', help='Signatures')
    parser.add_argument('--sharing', action='store_true', help='Sharing (should be the last thing)')
    args = parser.parse_args()

    config.read(args.config)

    if not config.has_option('Global', 'imapsync'):
        config.set('Global', 'imapsync', 'imapsync')
    if not config.has_option('Global', 'imapsync_opts'):
        config.set('Global', 'imapsync_opts', '')
    if not config.has_option('Source', 'admin_server'):
        config.set('Source', 'admin_server', config.get('Source', 'zimbra_server'))
    if not config.has_option('Source', 'imapsync_opts'):
        config.set('Source', 'imapsync_opts', '')
    if not config.has_option('Dest', 'admin_server'):
        config.set('Dest', 'admin_server', config.get('Dest', 'zimbra_server'))
    if not config.has_option('Dest', 'imapsync_opts'):
        config.set('Dest', 'imapsync_opts', '[]')

    with open(args.list) as f:
        accounts = f.read().splitlines()

    main(accounts)
